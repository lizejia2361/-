简单D触发器：

在数字电路中，D触发器是一种重要的时序电路。它具有数据存储和信号调节的功能，广泛应用于各种类型的计算机和电子设备中。
1.D触发器的定义和基本原理
      D触发器是一种基于门电路的存储器件，它包含一个数据输入、一个时钟输入和一个输出。其内部结构由多个门电路组成。
当时钟输入为高电平时，数据输入被传输到D触发器的输出端口，否则保持不变。
2.D触发器的功能和应用
      D触发器主要用于时序电路中的数据存储、信号同步和状态控制等方面。在计算机中，D触发器可以用来实现寄存器、计数器、
闸门等模块。在数字信号处理和通信领域，D触发器可以作为状态机等关键模块使用。
3.D触发器的特点
      D触发器具有以下几个特点：稳定性高、可靠性好、工作速度快、功耗低、封装形式多样等。同时，它还可以用于数字电路的
模拟仿真和实现逻辑运算等功能。

异步清零的D触发器：
1.独立于时钟控制的复位控制端。（就是 reset） 这样在任何时刻只要复位信号一来，输出直接清0。
2.异步复位优缺点：
优点：
a、大多数目标器件库的 DFF 都有异步复位端口，那么该触发器的复位端口就不需要额外的组合逻辑，这样就可以节省资源；
b、设计相对简单；
c、异步复位信号识别方便（电路在任何情况下都能复位而不管是否有时钟出现）。
缺点：
a、最大的问题在于它属于异步逻辑，问题出现在复位释放时，而不是有效时，如果复位释放接近时钟有效沿，则触发器的输出可
能进入亚稳态（此时 clk 检测到的 rst_n 的状态就会是一个亚稳态，即是0是1是不确定的），从而导致复位失败。
b、可能因为噪声或者毛刺造成虚假复位信号（比如以前的游戏机玩到一半突然复位）（注意：时钟端口、清零和置位端口对毛刺
信号十分敏感，任何一点毛刺都可能会使系统出错，因此判断逻辑电路中是否存在冒险以及如何避免冒险是设计人员必须要考虑的问题）；
————————————————
版权声明：本文为CSDN博主「Student_Yt」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/I_am_student/article/details/112317856


异步清零和置数的D触发器：
1.异步置数允许在时钟信号为高电平或低电平时立即将输出设置为逻辑"1"。无论时钟信号状态如何，只要置数输入处于有效状态，输出就会立即设置为"1"
2.异步清零允许在时钟信号为高电平或低电平时立即将输出清零为逻辑"0"。无论时钟信号状态如何，只要清零输入处于有效状态，输出就会立即被清零。
3.特点：
    a.异步置数和异步清零允许在时钟信号边沿之外对触发器进行控制，这使得触发器的状态可以立即改变，适用于特定的应用场景，如状态机的初始化或复位。
    b.异步置数和异步清零的优先级：在某些触发器设计中，当置数和清零同时有效时，置数具有更高的优先级。这意味着如果同时有置数和清零信号，触发器将会被置数。
    c.异步置数和异步清零的潜在问题：异步控制信号可能会导致时序问题和冲突。因为它们在时钟信号之外进行操作，可能会引入不稳定状态和噪声。因此，在设计中需
要小心处理异步信号，以确保稳定和可靠的操作。
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E5%85%B7%E6%9C%89%E5%BC%82%E6%AD%A5%E6%B8%85%E9%99%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8.png)

同步清零的D触发器：
     同步清零的D触发器是一种常见的数字电路元件，它是D触发器的一种变体，具有一个同步清零输入，允许在时钟信号的特定边沿时将输出清零。

逻辑：
    同步清零的D触发器有两个主要输入：D（数据输入）和 CLK（时钟输入），以及一个同步清零输入。在每个时钟周期的上升或下降沿（取决于特定设计），时钟信号
会对D触发器进行采样，并将输入数据存储在输出中。与异步清零不同，同步清零只在时钟边沿发生时才生效。
    同步清零输入通常用CLR或CLR\（取决于设计）表示。当CLR（或CLR\）为逻辑"1"时，在时钟边沿触发器的输出会被强制清零，无论数据输入D的状态如何。
特点：
1. 同步操作：与异步清零不同，同步清零在时钟信号的边沿进行操作，这意味着清零操作与时钟信号同步，有效地避免了时序问题和冲突。
2. 时序稳定性：同步清零确保清零操作在稳定的时钟边沿进行，因此避免了异步清零可能引入的不稳定状态和噪声。
3. 设计灵活性：同步清零允许在特定时钟边沿对输出进行清零，这为数字电路的设计提供了更大的灵活性和可控性。
4. 同步逻辑：同步清零的实现通常涉及与时钟信号同步的逻辑门电路，这可以在大规模集成（LSI）电路中实现，并且在高速应用中表现良好。
需要注意的是，在实际应用中，正确地处理同步清零信号的时序和相关设计问题是至关重要的。不当的时序规划可能导致不稳定的电路行为和故障。因此，在数
字电路设计中，应仔细考虑同步清零信号的特性和时序要求，以确保电路的正确功能和可靠性。
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E5%90%8C%E6%AD%A5%E7%BD%AE%E9%9B%B6%E8%A7%A6%E5%8F%91%E5%99%A8%E6%B3%A2%E5%BD%A2%E5%9B%BE.png)
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E5%90%8C%E6%AD%A5%E7%BD%AE%E9%9B%B6%E8%A7%A6%E5%8F%91%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png)


![](https://github.com/lizejia2361/-/blob/main/Lab4/%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8.png)
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8%E6%B3%A2%E5%BD%A2%E5%9B%BE.png)
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.png)


三种锁存器：
     普通D锁存器：
      锁存器对脉冲的电平敏感，也就是电平触发，在有效的电平下，锁存器处于使能状态，输出随着输入发生变化，此时它不锁存信号，就像一个缓冲器一样；
在锁存器没有使能时，则数据被锁住，输入信号不起作用，此时输出一直为锁存的状态信息（锁存最后一拍数据）。
我们常见的锁存器有SR锁存器、D锁存器、JK锁存器等
     异步清零和低电平使能的D锁存器：
逻辑：
    异步清零和低电平使能的D锁存器有三个主要输入：D（数据输入）、CLR（异步清零输入）和EN（低电平使能输入）。
    通常，锁存器在时钟信号的上升或下降沿采样数据输入，并根据EN的状态判断是否允许锁存或清零。
    1.数据输入（D）：D输入代表待存储的数据位。
    2.异步清零输入（CLR）：当CLR为逻辑"1"时，无论时钟信号和EN输入的状态如何，输出会被立即清零。
    3.低电平使能输入（EN）：EN为逻辑"0"时，锁存器处于使能状态。在使能状态下，锁存器会在时钟边沿根据数据输入（D）的值更新输出。当EN为逻辑"1"时，
锁存器被禁止更新，并保持之前的状态。
     异步置位和低电平清零的D锁存器：
逻辑：
异步置位和低电平清零的D锁存器有三个主要输入：D（数据输入）、SET（异步置位输入）和CLR（低电平清零输入）。通常，锁存器在时钟信号的上升或下降沿
采样数据输入，并根据SET和CLR的状态来判断是否置位或清零。

移位寄存器：
       首先，移位寄存器可以实现数据移位。这是因为移位寄存器的基本单元是触发器，它们可以存储二进制数据，且可以由时钟信号控制其状态的变化。当时钟信
号到达时，所有的触发器将同时被置位或复位，从而实现数据移位的目的。例如，4位移位寄存器在接收到时钟信号后，会使数据依次向左或向右移动一位。
       其次，移位寄存器可以用于数据暂存。在移位寄存器中，每个触发器都可以存储一个位。如果需要暂停输入数据，则可以通过使移位寄存器的时钟信号停止，
从而使数据暂停写入。
       第三，移位寄存器可以进行序列检测。移位寄存器可以通过向其中输入一系列数据，并通过计算Cyclic Redundancy Check (CRC) 来检测数据序列的完整性。
如果数据序列被破坏，则CRC值将与预期值不同，从而发现数据出错的情况。
       最后，移位寄存器输出数据的方式取决于所采用的移位方式，包括换进、换出、左移、右移等。换进新数据时，数据位被输入到动态移位寄存器中，然后输出
，例如串行进/串行出（SerialIn/SerialOut， SISO）和并行进/串行出（ParallelIn/SerialOut， PISO）移位寄存器。换出旧数据时，数据位被移出，然后新数据进
入它的空位中，例如串行进/并行出（SerialIn/ParallelOut， SIPO）和并行进/并行出（ParallelIn/ParallelOut， PIPO）移位寄存器。
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E4%B8%89%E7%A7%8DD%E9%94%81%E5%AD%98%E5%99%A8.png)
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E9%94%81%E5%AD%98%E5%99%A8%E7%9A%84%E7%94%B5%E8%B7%AF%E5%9B%BE.png)
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E4%B8%89%E7%A7%8D%E9%94%81%E5%AD%98%E5%99%A8%E7%9A%84%E6%B3%A2%E5%BD%A2%E5%9B%BE.png)

阻塞与非阻塞及其区别：
一、阻塞和非阻塞

阻塞和非阻塞指的是调用者（程序）在等待返回结果（或输入）时的状态。阻塞时，在调用结果返回前，当前线程会被挂起，并在得到结果之后返回。非阻塞时，如果不能立刻得到结果，则该调用者不会阻塞当前线程。因此对应非阻塞的情况，调用者需要定时轮询查看处理状态。

阻塞：为了完成一个功能，发起一个调用，如果不具备条件的话则一直等待，直到具备条件则完成

非阻塞：为了完成一个功能，发起一个调用，具备条件直接输出，不具备条件直接报错返回
二、区别

其实就相当于在捕捉一个子进程退出的时候，阻塞则会一直等待，直到这个子进程退出，返回对应的值，而非阻塞，如果刚好捕捉到子进程的退出则直接输出，如果没有捕捉到，也不进行等待，直接输出报错。

延伸阅读

阻塞赋值与非阻塞赋值的使用场合

(1) 时序电路建模时，用非阻塞赋值。
(2) 锁存器电路建模时，用非阻塞赋值。
(3) 用always块建立组合逻辑模型时，用阻塞赋值。
(4) 在同一个always块中建立时序和组合逻辑电路时，用非阻塞赋值。
(5) 在同一个always块中不要既用非阻塞赋值又用阻塞赋值。
(6) 不要在一个以上的always块中为同一个变量赋值。
(7) 用$strobe系统任务来显示用非阻塞赋值的变量值。
(8) 在赋值时不要使用#0延时。
组合逻辑电路：使用阻塞赋值（“=”）；时序逻辑电路：使用非阻塞赋值（“<=”）

来源：本文为CSDN博主「闲庭信步sss」的原创文章
原文链接：https://blog.csdn.net/spx1164376416/article/details/124289951

   1.数据输入（D）：D输入代表待存储的数据位。
    2.异步置位输入（SET）：当SET为逻辑"1"时，无论时钟信号和CLR输入的状态如何，输出会立即被设置为高电平（置位）。
    3.低电平清零输入（CLR）：CLR为低电平使能输入。当CLR为逻辑"0"时，无论时钟信号和SET输入的状态如何，输出会立即被清零。
![](https://github.com/lizejia2361/-/blob/main/Lab4/%E4%B8%A4%E8%BE%93%E5%85%A5%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8%E6%A8%A1%E5%9E%8B.png)
