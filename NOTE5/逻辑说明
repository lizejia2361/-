1.按键消抖
以上代码实现了一个键盘去抖动模块（key_debounce），用于消除按键信号中的抖动，确保正确检测按键的按下和释放。

该模块包含以下输入和输出：

输入：
- clk：时钟信号，用于同步处理按键信号。
- rst_n：复位信号，低电平有效。
- key：按键信号，表示当前按键状态，高电平表示按下，低电平表示释放。

输出：
- flag：标志位，指示按键去抖动后的状态是否有效，高电平表示有效，低电平表示无效。
- key_value：按键值，表示经过去抖动处理后的按键状态，与flag配合使用。

下面对代码逻辑进行解释：

1. 声明了一个名为delay_cnt的20位寄存器，用于延迟计数。
2. 声明了一个名为key_reg的寄存器，用于存储前一个时钟周期的按键状态。

在always块1中，根据时钟和复位信号的边沿触发条件，对key_reg和delay_cnt进行更新：
- 当复位信号（rst_n）为低电平时，表示复位状态，将key_reg设置为1'b1（按键释放状态）；将delay_cnt设置为1'b0（清零延迟计数器）。
- 当复位信号为高电平时，根据按键状态的变化来更新key_reg和delay_cnt：
  - 如果前一个时钟周期的按键状态（key_reg）为1（按键释放状态）且当前按键状态（key）为0（按键按下状态），则将delay_cnt设置为20'd1_000_000（延迟计数器的初始值）。
  - 否则，如果延迟计数器（delay_cnt）大于0，则将延迟计数器减1。
  - 如果延迟计数器等于0，则将delay_cnt设置为1'b0（清零延迟计数器）。

在always块2中，根据时钟和复位信号的边沿触发条件，对flag和key_value进行更新：
- 当复位信号为低电平时，表示复位状态，将flag设置为1'b0（无效状态）；将key_value设置为1'b1（按键释放状态）。
- 当复位信号为高电平时，根据延迟计数器（delay_cnt）的值来更新flag和key_value：
  - 如果延迟计数器等于20'd1（经过一定延迟后），则将flag设置为1'b1（有效状态）；将key_value设置为当前按键状态（key）。
  - 否则，将flag保持为1'b0（无效状态）；将key_value保持为上一个时钟周期的值（key_value）。


因此，该模块通过延迟计数器来检测按键状态的稳定性，只有当按键状态经过一定的延迟时间保持稳定后，才认为是有效的按键操作。通过flag信号可以判断按键操作是否有效，而key_value信号则表示经过去抖动处理后的按键状态。

具体的逻辑如下：
- 在always块1中，当按键从释放状态（key_reg为1）变为按下状态（key为0）时，延迟计数器（delay_cnt）被设置为一个初始值（20'd1_000_000），即开始进行倒计时。
- 如果延迟计数器大于0，则每个时钟周期减1，直到倒计时结束。
- 一旦延迟计数器（delay_cnt）为0，说明按键状态已经稳定保持一段时间，并且flag被设置为1，表示按键操作有效。
- 在always块2中，根据延迟计数器（delay_cnt）的状态，更新flag和key_value的值：
  - 如果延迟计数器等于20'd1，说明按键状态已经稳定，将flag设置为1，表示按键操作有效，同时将key_value设置为当前的按键状态（key）。
  - 如果延迟计数器不等于20'd1，则表示按键状态还未稳定，将flag保持为0（无效状态），同时将key_value保持为上一个时钟周期的值。

通过以上逻辑，该键盘去抖动模块可以消除按键信号的抖动，并提供一个稳定的按键状态，确保正确地检测按键的按下和释放。




2.数码管扫描
 以上代码实现了一个数码管扫描模块（seg_scan），用于根据输入的money_flag和sel信号选择相应的数码管显示内容。

该模块包含以下输入和输出：

输入：
- clk：时钟信号，用于同步处理。
- rst_n：复位信号，低电平有效。
- money_flag：4位输入信号，表示货币标志。
- sel：6位输入信号，选择要显示的数码管。

输出：
- seg：8位输出信号，用于控制数码管的段选。

下面对代码逻辑进行解释：

在always块1中，根据money_flag和sel信号的组合，确定要显示的数字（number）和标志位（flag）的值：
- 使用case语句根据money_flag进行选择。
- 根据sel信号的不同组合，分别确定要显示的数字和标志位的值。

在always块2中，根据number和flag的值，设置seg_r信号，即数码管的段选控制信号：
- 使用case语句根据number的值进行选择。
- 如果flag为1，表示标志位有效，设置对应数字的段选控制信号。
- 如果flag为0，表示标志位无效，设置对应数字的段选控制信号，同时在显示的数字上加一个小点。

最后，通过assign语句将seg_r赋值给seg，将seg作为输出信号。

通过以上逻辑，该数码管扫描模块根据输入的货币标志和选择信号，选择相应的数字进行显示，并根据标志位的值控制是否显示小数点。

在该模块中，根据输入的money_flag和sel信号的不同组合，使用case语句进行选择，并设置对应的数字（number）和标志位（flag）的值。

在always块1中，首先根据money_flag进行选择。根据sel信号的不同组合，可以设置以下情况：

- 如果sel为6'b111_110，表示选择的是第一个数码管，number被设置为相应的值（如4'd0、4'd5等），同时flag被设置为0或1，表示标志位的有效性。
- 如果sel为6'b111_101，表示选择的是第二个数码管，number被设置为相应的值，flag被设置为0或1。
- 对于其他sel信号的组合，number被设置为4'd0，表示不显示任何数字，flag被设置为0，表示标志位无效。

在always块2中，根据number和flag的值，设置seg_r信号，即数码管的段选控制信号。使用case语句根据number的值进行选择，设置对应数字的段选控制信号。

- 如果flag为1，表示标志位有效，设置对应数字的段选控制信号，例如显示数字0时，seg_r被设置为8'b0100_0000。
- 如果flag为0，表示标志位无效，设置对应数字的段选控制信号，并在显示的数字上加一个小点，例如显示数字0时，seg_r被设置为8'b1100_0000。

最后，通过assign语句将seg_r赋值给seg，将seg作为输出信号，用于控制数码管的段选。

通过以上逻辑，该seg_scan模块能够根据输入的money_flag和sel信号选择相应的数字和标志位，并控制数码管的段选信号，实现相应的数字显示。
3.选择信号驱动
以上代码实现了一个选择信号驱动模块（sel_drive），用于控制一个6位选择信号sel的生成。

该模块包含以下输入和输出：

输入：
- clk：时钟信号，用于同步处理。
- rst_n：复位信号，低电平有效。
- boot_flag：引导标志位，用于指示引导状态。

输出：
- sel：6位输出信号，用于选择其他模块的某个特定功能。

下面对代码逻辑进行解释：

在该模块中，使用一个计数器cnt和一个选择标志位sel_flag来控制选择信号sel的生成。

在always块1中，根据时钟信号和复位信号更新计数器cnt的值。当复位信号为低电平时，将cnt重置为0；当计数器cnt达到最大值（MAX_NUM），将cnt重置为0。否则，计数器cnt递增1。

在always块2中，根据时钟信号和复位信号更新选择标志位sel_flag的值。当复位信号为低电平时，将选择标志位sel_flag设为0；当计数器cnt达到最大值时，选择标志位sel_flag取反；否则，选择标志位sel_flag保持不变。

在always块3中，根据时钟信号和复位信号以及引导标志位boot_flag更新选择信号sel的值。当复位信号为低电平时，选择信号sel被设置为全1（6'b111_111）；否则，根据引导标志位boot_flag选择不同的情况。

- 如果boot_flag为0，表示处于非引导状态，选择信号sel被设置为全1（6'b111_111）。
- 如果boot_flag为1，表示处于引导状态，根据选择标志位sel_flag的值设置选择信号sel的值。
  - 当sel_flag为0时，选择信号sel被设置为6'b111_110。
  - 当sel_flag为1时，选择信号sel被设置为6'b111_101。
  - 其他情况下，选择信号sel保持不变。

最后，通过assign语句将sel_r赋值给sel，将sel作为输出信号。

通过以上逻辑，该sel_drive模块能够根据引导标志位和选择标志位生成相应的选择信号sel，并根据时钟信号和复位信号进行更新和控制。这样可以实现选择信号的驱动功能，以选择其他模块的特定功能。
在该模块中，计数器cnt的作用是生成一个周期为MAX_NUM的计数周期，用于控制选择信号sel的切换频率。当cnt达到最大值时，选择标志位sel_flag取反，实现选择信号的周期性切换。

选择标志位sel_flag决定了选择信号sel的具体取值。当sel_flag为0时，选择信号sel取值为6'b111_110；当sel_flag为1时，选择信号sel取值为6'b111_101。这样可以根据sel_flag的变化来周期性地切换选择信号的值。

引导标志位boot_flag用于指示模块的引导状态。当boot_flag为0时，表示处于非引导状态，选择信号sel被设置为全1（6'b111_111），即不选择任何特定功能。当boot_flag为1时，表示处于引导状态，根据选择标志位sel_flag的值设置选择信号sel的值。

最后，通过assign语句将sel_r赋值给sel，将sel作为输出信号。这样，其他模块可以根据选择信号sel的值执行相应的功能。

综上所述，sel_drive模块通过计数器、选择标志位和引导标志位的组合，实现了周期性切换选择信号的功能，可以根据引导状态和选择标志位来选择特定的功能，从而满足系统的需求。
4.顶层模块
上述代码描述了一个顶层模块 `top_vending_machine`，该模块实例化了多个子模块来完成自动售货机的逻辑。

输入端口包括：
- `clk`：时钟信号
- `rst_n`：复位信号
- `key`：4位按键输入

输出端口包括：
- `beep`：蜂鸣器信号，用于控制蜂鸣器的开关
- `led`：4位 LED 灯显示
- `seg`：8位数码管显示
- `sel`：6位选择信号，用于控制数码管的选择

该顶层模块实例化了以下子模块：

1. `key_debounce` 模块实例化了4个按键去抖动子模块（`inst_key_debounce1`、`inst_key_debounce2`、`inst_key_debounce3`、`inst_key_debounce4`）。这些子模块用于消除按键输入的抖动，每个按键对应一个子模块。每个子模块接收时钟信号 `clk`、复位信号 `rst_n` 和按键输入 `key`，输出对应的去抖动结果到 `flag` 端口，以及按键值到 `key_value` 端口。

2. `sel_drive` 模块用于驱动数码管的选择信号。它接收时钟信号 `clk`、复位信号 `rst_n` 和启动标志位 `boot_flag`，并根据输入的启动状态生成选择信号 `sel`。

3. `seg_scan` 模块用于驱动数码管的显示。它接收时钟信号 `clk`、复位信号 `rst_n` 和货币标志位 `money_flag`，以及选择信号 `sel`，并根据货币标志位和选择信号来生成数码管的显示输出 `seg`。

4. `vending_machine` 模块是核心逻辑实现，用于控制自动售货机的各项功能。它接收时钟信号 `clk`、复位信号 `rst_n`、按键值 `key_value` 和标志位 `flag`。它还包括输出端口 `beep`（控制蜂鸣器）、`led`（LED 灯显示）、`money_flag_w`（货币标志位输出）和 `boot_flag_w`（启动标志位输出）。该模块根据输入的按键值和标志位，实现了自动售货机的逻辑功能。

总体而言，顶层模块 `top_vending_machine` 实例化了多个子模块，并将它们连接在一起，完成了自动售货机的整体逻辑实现。
5.自动售货机逻辑
以上代码实现了一个名为 `vending_machine` 的模块，这个模块描述了一个自动售货机的逻辑。

该模块有以下输入端口：
- `clk`：时钟信号
- `rst_n`：复位信号
- `key_value`：按键值，4位输入
- `flag`：标志位，4位输入

该模块有以下输出端口：
- `beep`：蜂鸣器信号，用于控制蜂鸣器的开关
- `led`：LED灯显示，4位输出
- `money_flag_w`：货币标志位，4位输出
- `boot_flag_w`：启动标志位，1位输出

在该模块中定义了一些参数：
- `MAX_NUM`：用于计时的最大值，控制计时周期为0.2秒
- `MAX_NUM2`：用于计时的最大值，控制计时周期为2秒

接下来，模块内部定义了一些寄存器和标志位用于实现逻辑功能。具体逻辑如下：

1. 计时功能：
   - 使用 `cnt` 寄存器实现0.2秒的计时器。每当 `cnt` 达到 `MAX_NUM` 时，计时器归零。
   - 使用 `cnt_1` 寄存器实现2秒的计时器。当 `time_flag` 为1时，每当 `cnt` 达到 `MAX_NUM` 时，`cnt_1` 递增，直到达到 `MAX_NUM2` 后归零。

2. 启动标志位控制：
   - 使用 `boot_flag` 寄存器表示启动标志位，初始值为0。
   - 当按下 `flag[3]` 对应的按键且 `key_value[3]` 为低电平时，`boot_flag` 取反，用于切换启动状态。
   - `beep` 寄存器用于控制蜂鸣器的开关，与 `boot_flag` 取反相同。

3. 货币标志位控制：
   - 使用 `money_flag` 寄存器表示货币标志位，初始值为0，表示无投币状态。
   - 当 `boot_flag` 为1（启动状态）时，根据按键的组合设置 `money_flag` 的值：
     - 如果按下 `flag[1]` 对应的按键且 `key_value[1]` 为低电平，则 `money_flag` 设置为1，表示投入0.5元。
     - 如果按下 `flag[2]` 对应的按键且 `key_value[2]` 为低电平，则 `money_flag` 设置为2，表示投入1元。
     - 如果按下 `flag[0]` 对应的按键且 `key_value[0]` 为低电平，则 `money_flag` 设置为7，表示退还所有已投币，并设置 `time_flag` 为1，

继续上述逻辑：

4. 计时和退币控制：
   - 如果 `money_flag` 为1或2（投入0.5元或1元），则根据计时器 `cnt_1` 的值来决定是否退币：
     - 当 `cnt_1` 达到 `MAX_NUM2` 时，即2秒过去后，将 `money_flag` 设为0，表示退还已投币，并将 `time_flag` 设为0。
   - 如果 `money_flag` 为7（退币状态），则根据计时器 `cnt_1` 的值来决定是否结束退币：
     - 当 `cnt_1` 达到 `MAX_NUM2` 时，即2秒过去后，将 `money_flag` 设为0，并将 `time_flag` 设为0。

5. LED灯显示控制：
   - 根据不同的 `money_flag` 和 `led_flag` 组合来控制 LED 灯的显示：
     - 当 `money_flag` 为5（投入2.5元）时，根据 `led_flag` 的值来交替显示全亮和全灭的状态。
     - 当 `money_flag` 为6（投入3元）时，根据 `led_flag` 的值来依次显示四个灯的亮灭状态。
     - 当 `money_flag` 为7（退币状态）时，根据 `led_flag` 的值来依次显示逐渐点亮的灯。

最后，将计算得到的 `money_flag` 和 `boot_flag` 分别输出到 `money_flag_w` 和 `boot_flag_w` 端口，LED 灯的状态输出到 `led` 端口。

总体而言，该模块实现了一个简单的自动售货机的逻辑，根据按键的输入和状态的变化，控制蜂鸣器、LED 灯的显示以及货币的投入和退还。

